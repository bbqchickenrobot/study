Beginning_Ruby_From_Novice_to_Professional

-   Chapter 2 Programming == JOY: A Whistle-stop tour of Ruby and Object
    Orientation

    -   irb - interactive ruby. It is like a cmd line terminal program.

        irb(main):001:0> class Person
        irb(main):002:1> attr_accessor :name, :age, :gender
        irb(main):003:1> end
        => nil
        irb(main):004:0>        

        Note: Ruby knew that you were now within a class structure, defining
        a class, rather than typing code to be processed immediately. The
        1 represents that you're at a depth of 1 of nested concepts.

        defining a class results in no return value, and nil is Ruby's
        way of representing "nothing".
        

    -   define a class example code:

        class Person
            attr_accessor :name, :age, :gender
        end

        Note:   1)  Class names in Ruby always start with a capital letter
                2)  attr stands for "attribute" and accessor roughly means
                    "make these attributes accessible to be set and changed
                    at will"
                3)  end line mathes up the class definition

    -   Basic of using a class

        -   Create an object
        
            person_instance = Person.new

        -   Set attributes

            person_instance.age = 52

        -   Print attributes

            puts person_instance.name

        -   Inheritance

            class Pet
                attr_accessor :name, :age, :gender, :color
            end

            class Cat < Pet
            end

            class Dog < Pet
            end

            class Snake < pet
                attr_accessor :length
            end

            note: length is the attribte that isn't relevant to
            every animal.

        -   Methods

            -   How to add a method to a class:

                class Dog < Pet
                    def bark
                        puts "Woof!"
                    end
                end

            -   How to use the method?

                irb(main):0> a_dog = Dog.new
                irb(main):0> a_dog.bark

            -   Passing Data to Methods

                Kernel.puts "Hello, world"

                or

                Kernel.puts("Hello, world!")

                note:

                1)  puts ia a method of the Kernel module that is included
                    and searched by default, so usually you won't need to
                    use Kernel.puts to refer to it.

                2)  Parentheses are not strictly necessary. Often, however
                    , parentheses are required, as in many situation
                    omitting them leaves the code vague and imprecise.

        -   Which class am I?

            e.g. puts 2.class => Fixnum

    -   Everything in Ruby is an object        

        puts 1 + 10

        In the above statement, even 1 and 10 are objects of class Fixnum

    -   String related methods:

        Expression                  Output

        "Test" + "Test"	            TestTest
        "Test".capitalize	        Test
        "Test".downcase	            test
        "Test".chop	                Tes
        "Test".next	                Tesu
        "Test".reverse	            tseT
        "Test".sum	                416
        "Test".swapcase	            tEST
        "Test".upcase	            TEST
        "Test".upcase.reverse	    TSET
        "Test".upcase.reverse.next	TSEU

-   Chapter 3   Ruby's Building Blocks: Data, Expressions, and Flow Control

    -   Examples

        -   if statement

            age = 24
            puts "You're a teenager" if age > 12 && age < 20

        -   unless statement

            age = 24
            puts "You're NOT a teenager" unless age > 12 && age < 20

        -   x <=> y

            x <=> y means Comparison; return 0 if x and y are equal, 1 if x is higher, and -1 if y is higher

    -   Looping Through Numbers with Blocks and Iterators

        -   Fixnum.times method

            5.times do puts "Test" end

            or

            5.times {puts "Test"}

            note: parentheses are used to replace the "do end" couple.

            In Ruby, one mechanism to create a loop is called an iterator. An iterator is something that progresses through a list
            of items one by one. E.g.

            1.upto(5) { ...code to loop here... }
            10.downto(5) { ...code to loop here... }
            0.step(50, 5) { ...code to loop here... }

            The first and second examples are self-explainatory. The third example counts up from 0 to 50 in steps of 5

            How to get hold of the number being iterated upon at each step of the way so that you can do something with it in the looped
            code. What if you wanted to print out the current iteration number? Thanksfully, all of the iterators just explained automatically
            pass the state of the iteration to the looped code as a parameter, which you can then retrieve into a variable and use, like:

            1.upto(5) {|number| puts number}

            |number| is the way how a parameters are passed into blocks of code that don't have specific names. Another way of writing the above
            block of code is like:

            1.upto(5) do |number|
                puts number
            end
     
        -   Constants

            Any variable beginning with a capital letter, for example:

            Pi = 3.141592

        -   Text and Strings

            -   Assigning String value

                The simlest form of assigning a string value is:
            
                x = "Test"
                y = "String"
                puts "Success!" if x + y == "TestString"

                There are several other ways of including a string literal within a program. If you want to include multiple lines of text, try this:

                x = %q{This is a test
                of the multi
                line capabilities}

                You don't have to use curly brackets, anything pairs of symbols for example: < and >, ( and ) or simply two other delimiters of your choice
                such as ! and !.

                Another way to build up a long string literal is by using a "here document". The concept is very similar to the previous example, except that
                the delimiter can be many characters long. Here's an example:

                x = <<END_MY_STRING_PLEASE
                This is the string
                And a second line
                END_MY_STRING_PLEASE

            -   String Expressions

                -   1) puts "abc" * 5
                    "abcabcabcabcabc"

                -   2) puts "x" > "y"
                    false

                -   3) if you are interested to learn what value a particular character has, find out like so:

                    puts "x".ord
                    120

                -   4) A reverse method for above statement

                    puts 120.chr
                    x

                -   Interpolation

                    You can embed expressions (and even logic ) directly into strings. This is so called interpolation. The way of interpolate
                    a string is to place the expression within #{and} symbols. E.g.

                    puts "100 * 5" = #{100 * 5}"

                    The #{100 * 5} section interpolates the result of 100 * 5(500) into the string at that position, resulting in th output shown.

                    Another example to demo this concept is:

                    puts "It's a #{"bad " * 5 }"

                -   Other string methods

                    Expression                  Output                    

                    "Test" + "Test"	            TestTest
                    "Test".capitalize	        Test
                    "Test".downcase	            test
                    "Test".chop	                Tes
                    "Test".next	                Tesu
                    "Test".reverse	            tseT
                    "Test".sum	                416
                    "Test".swapcase	            tEST
                    "Test".upcase	            TEST
                    "Test".upcase.reverse	    TSET
                    "Test".upcase.reverse.next	TSEU
                    "Test".length               4

            -   Regular expression and String Manipulation

                A regular expression is a string that describes a pattern for matching elements in other strings.

                -   Subsitutions

                    puts "foobar".sub('bar', 'foo')
                    foofoo

                    The above example demo a single sub. For multiple sub, look at the below example:

                    puts "this is a test".gsub('i', '')
                    ths s a test
                                       
                    For more complicated examples such as to replace the first two characters of a string with 'Hello'

                    puts "this is a test.gsub(/^../, "Hello")"
                    Hellois is a test
            
                    The ^ is an anchor, meaning the regular expression will match from the beginning of any lines within the string
                    The two periods each represent “any character.” In all, /^../ means “any two characters immediately after the 
                    start of a line.”

                    Likewise, if you want to change the last two characters, you can use a different anchor:

                    x = "This is a test"
                    puts x.sub(/..$/, 'Hello')
                    This is a teHello

                -   Iteration with a regular Expression

                    What if you want to iterate through a string and have access to each section of it
                    separately? scan is the iterator method you require:

                    "xyz".scan(/./) { |letter| puts letter }
                    x
                    y
                    z

                    Another example to demo to iterate through every two characters:

                    "This is a test".scan(/../) {|x| puts x}
                    
                    Th
                    is
                     i
                    s 
                    a 
                    te
                    st

                    The result is weird with all spaces mixed in. Let's adjust our regular expression to match only letters and digits, like so:
                    
                    "This is a test".scan(/\w\w/) { |x| puts x }

                    Th
                    is
                    is
                    te
                    st

                    \w means “any alphanumeric character or an underscore.

                    Character   Meaning

                    ^	        Anchor for the beginning of a line
                    $	        Anchor for the end of a line
                    \A	      Anchor for the start of a string
                    \Z	      Anchor for the end of a string
                    .	        Any character
                    \w	      Any letter, digit, or underscore
                    \W	      Anything that \w doesn’t match
                    \b        Matches word boundaries when outside brackets; backspace (0x08) when inside brackets
                    \B        Matches non-word boundaries
                    \d	      Any digit
                    \D	      Anything that \d doesn’t match (non-digits)
                    \s	      Whitespace (spaces, tabs, newlines, and so on)
                    \S	      Non-whitespace (any visible character)

                    Another example:

                    "The car costs $1000 and the cat costs $10".scan(/\d+/) do |x|
                    puts x
                    end

                    1000
                    10
                    
                    The + that follows \d makes \d match as many digits in a row as possible. '+' after a character in a regular expression means 
                    match one or more of that type of character. There are other types of modifiers, and these are shown below:

                    Modifier	        Description
                    *	                Match zero or more occurrences of the preceding character, and match as many as possible.
                    +	                Match one or more occurrences of the preceding character, and match as many as possible.
                    *?	                Match zero or more occurrences of the preceding character, and match as few as possible.
                    +?	                Match one or more occurrences of the preceding character, and match as few as possible.
                    ?	                Match either one or none of the preceding character.
                    {x}	                Match x occurrences of the preceding character.
                    {x,y}	            Match at least x occurrences and at most y occurrences.

                    Last but not least, you can use "character classes" to match against a specific set of characters. E.g.

                    "This is a test".scan(/[aeiou]/) { |x| puts x }

                    i
                    i
                    a
                    e

                    another example: 

                    "This is a test".scan(/[a-m]/) { |x| puts x }
                    
                    h
                    i
                    i
                    a
                    e

                -   Matching
                
                    Making substitions and extracting certain text from strings is useful, but sometimes you merely want to check whether a certain string
                    matches against the pattern of your choice. Let's look at one example:

                    puts "String has vowels" if "This is a test" =~ /[aeiou]/
                
                    =~ is another form of operator: a matching operator. If the string has a match with the regular expression following the operator, then 
                    the expression returns the position of the first match.
        
                    It's possible to use a method called match, provided by the String class. Match can provide more power than =~. Here is an example:

                    puts "String has vowels" if "This is a test".match(/[aeiou]/)

                    In regular expressions, if you surround a section of the expression with parentheses - ( and ) - the data matched by that section of the
                    regular expression is made available separately from the rest.match lets you access the data(??):

                    x = "This is a test".match(/(\w+) (\w+)/)
                    puts x[0]
                    puts x[1]
                    puts x[2]

                    This is
                    This
                    is

                    match returns a MatchData object that can be accessed like an array. The first element
                    (x[0]) contains the data matched by the entire regular expression. However, each successive
                    element contains that which was matched by each match group of the regular expression. In
                    this example, the first (\w+) matched This and the second (\w+) matched is.


        -   Arrays and Lists

            x = [1, 2, 3, 4]
            puts x[2]
            
            3

            -   You can create an empty array like:

                x = []

            -   Push data into an array

                x << "Word"
                
                After this, the array contains a single element: a string saying "Word". << is the operator for pushing an item into the end of an array. You can
                also use the push method: 

                x.push("Word")

            -   Remove entries from arrays

                x = []
                x << "Word"
                x << "Play"
                x << "Fun"
                puts x.pop
                puts x.pop
                puts x.length

                Fun
                Play
                1

            -   If array is full of strings, you can join all the elements together into one big string by calling the join method on the array:

                x = ["Word", "Play", "Fun"]
                puts x.join

                WordPlayFun

                or 

                x = ["Word", "Play", "Fun"]
                puts x.join(', ')

                Word, Play, Fun

            -   Splitting Strings into Arrays

                You can use the split method to split a string into multiple pieces. Like so:

                puts "Short sentence. Another. No more.".split(/\./).inspect

                ["Short sentence", " Another", " No more"]

                Note:

                1)      In the regular expression rather than ., you'd be splitting on every character rather than on full stops, 
                        because . represents "any character" in a regular expression. Therefore, you have to escape(escaping is
                        process of specifically denoting a character to make its meaning clear) it by prefixing it with a backslash; 

                2)      The inspect method is common to almost all built-in classes in Ruby and it gives you a textual representation 
                        of the object. You can use 'p' to replace inspect. E.g.
    
                        p "Words with lots of spaces".split(/\s+/)

                        ["Words", "with", "lots", "of", "spaces"]

            -   Array Iteration

                -   example 1: use "each" method

                    [1, "test", 2, 3, 4].each { |element| puts element.to_s + "X" }

                    1X
                    testX
                    2x
                    3x
                    4x

                -   example 2: use "collect" method

                    Although each iterates through elements of an array, you can also convert an array on the fly using the collect method:

                    [1, 2, 3, 4].collect { |element| element * 2 }

                    [2, 4, 6, 8]

                    collect iterates through an array element by element, and assigns to that element the result of any expression within the code block.

                    note: map function is the same as collect

                -   example 3: use the regular method

                    while (i < a.length)
                      puts a[i].to_s + "X"
                      i += 1
                    end
                

            -   Other array methods

                -   Addition +

                    x = [1, 2, 3]
                    y  = ["a", "b", "c"]
                    z = x + y
                    p z

                    [1, 2, 3, "a", "b", "c"]

                -   Subtraction -

                    x = [1, 2, 3, 4, 5]
                    y = [1, 2, 3]
                    z = x - y
                    p z

                    [4, 5]

                -   empty array check

                    x = []
                    puts "x is empty" if x.empty?

                    x is empty

                -   checking an Array for a Certain item
                                        
                    x = [1, 2, 3]
                    p x.include?("x")
                    p x.include?(3)

                    false
                    true

                -   Accessing the first/last element of the array

                    x = [1, 2, 3]
                    puts x.first
                    puts x.last

                    1
                    3

                    x = [1, 2, 3]
                    puts x.first(2).join("-")

                    1-2

                -   Reversing the order

                    x = [1, 2, 3]
                    p x.reverse
    
                    [3, 2, 1]

        -   Hashes

            directionary = {'cat' => 'feline animal', 'dog' => 'canine animal'}

            puts directionary.size
            
            2

            -   Basci Hash Methods

                -   Iterate through Hash Elements

                    x = { "a" => 1, "b" => 2 }
                    x.each { |key, value| puts "#{key} equals #{value}" }

                    a equals 1
                    b equals 2

                    In Ruby 1.8, there is no guarantee that elements will be returned in a specific order. In Ruby 1.9,
                    however, the order in which the elements were inserted into the hash will be remembered, and each will
                    return them in that order.

                -   Retrieving keys

                    x = { "a" => 1, "b" => 2, "c" => 3 }
                    p x.keys

                    ["a", "b", "c"]

                -   Delete Hash Elements

                    x = { "a" => 1, "b" => 2 }
                    x.delete("a")
                    p x

                    {"b"=>2}

                -   Deleting Hash Elements Conditionally
                    
                    x = { "a" => 100, "b" => 20 }
                    x.delete_if { |key, value| value < 25 }
                    p x

                    {"a"=>100}

            -   Hash Within Hashes

                people = {
                    'fred' => {
                        'name' => 'Fred Elliott',
                        'age' => 63,
                        'gender' => 'male',
                        'favorite painters' => ['Monet', 'Constable', 'Da Vinci']
                    },
                    'janet' => {
                        'name' => 'Janet S Porter',
                        'age' => 55,
                        'gender' => 'female'
                    }
                }

                puts people['fred']['age']
                puts people['janet']['gender']
                p people['janet']

                63
                female
                {"name"=>"Janet S Porter", "gender"=>"female", "age"=>55}

                Even the array embedded within Fred’s hash is easy to access:
                puts people['fred']['favorite painters'].length
                puts people['fred']['favorite painters'].join(", ")

                3
                Monet, Constable, Da Vinci

            -   Flow Control

                -   if and unless
                -   ? the Ternary Operator
                -   elsif and case

                    fruit = "orange"
                    if fruit == "orange"
                        color = "orange"
                    elsif fruit == "apple"
                        color = "green"
                    elsif fruit == "banana"
                        color = "yellow"
                    else
                        color = "unknown"
                
                    fruit = "orange"
                    case fruit
                        when "orange"
                        color = "orange"
                        when "apple"
                        color = "green"
                        when "banana"
                        color = "yellow"
                        else
                        color = "unknown"
                    end

                    You can use another trick to shorten the above example:

                    fruit = "orange"
                    color = case fruit
                      when "orange"
                      "orange"
                      when "apple"
                      "green"
                      when "banana"
                      "yellow"
                      else
                      "unknown"
                    end

                -   while and until

                    x = 1
                    until x > 99
                      puts x
                      x = x * 2
                    end

                    It's also possible to while and until in a single line setting:

                    i = 1
                    i = i * 2 until i > 1000
                    puts i

                    1024

                -   Code Blocks

                    The code between { and } or do and end is a code block. Another example(!!)

                    def each_vowel(&code_block)
                      %w{a e i o u}.each { |vowel| code_block.call(vowel) }
                    end

                    each_vowel { |vowel| puts vowel }

                    a
                    e
                    i
                    o
                    u

                    each_vowel is a method that accepts a code block, as designated by the ampersand(&) before the variable name code_block in the method
                    definition. It then iterates over each vowel in the literal array %w{a e i o u} and uses the call method on code_block to execute
                    the code block for each vowel, passing in the vowel variable as a parameter each time. 

                    Note: Code blocks passed in this way result in objects that have many methods of their own, such as "call".

                    Another alternate technique is to use the yield method, which automatically detects any passed code block and passes control to it:

                    def each_vowel
                      %w{a e i o u}.each { |vowel| yield vowel}
                    end

                    each_vowel {|vowel| puts vowel }

                    The last method you can use is to store code blocks within variable, using the lambda method:

                    print_parameter_to_screen = lambda { |x| puts x }
                    print_parameter_to_screen.call(100)

                    100

                -   Other Useful Building Blocks
    
                    -   Dates and Times
                    -   Large Numbers
                    -   Ranges

                        x = ['A', 'B', 'C'..., 'Z'] can be written as a representation of a range

                        ('A'..'Z')

                        The Range class provides a simple way to convert a range into an array with to_a:

                        ('A'..'Z').to_a.each{|letter| print letter}

                        ABCDEFGHIJKLMNOPQRSTUVWXYZ=> 
                        ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z"]

                        You can check if R is within the range, using the include? method, like so:

                        ('A'..'Z').include?('R')

                        => true

                    -   Symbols

                        current_situation = :good
                        puts "Everything is fine" if current_situation == :good
                        puts "PANIC!" if current_situation == :bad

                        => Everything is fine

                        Here :good and :bad are symbols. 

                        Symbols don’t contain values or objects, like variables do. Instead, they’re used as a consistent 
                        name within code. For example, in the preceding code, you could easily replace the symbols with strings, like so:

                        current_situation = "good"
                        puts "Everything is fine" if current_situation == "good"
                        puts "PANIC!" if current_situation == "bad"

                        This gives the same result, but isn’t as efficient. In this example, every mention of “good”
                        and “bad” creates a new object stored separately in memory, whereas symbols are single refer-
                        ence values that are only initialized once. In the first code example, only :good and :bad exist,
                        whereas in the second example, you end up with the full strings of "good", "good", and "bad"
                        taking up memory.

                        You might want to consider symbols to be literal constants that have no value, but whose
                        name is the most important factor.

                        Symbols are particularlu useful when creating hashes and you want to have a distinction between keys and values. E.g.

                        s = { :key => 'value' }
            
                        This technique can also be useful when there’s a specification or consistency in which key
                        names to use:

                        person1 = { :name => "Fred", :age => 20, :gender => :male }
                        person2 = { :name => "Laura", :age => 23, :gender => :female }


-  Chapter 4 Your first Ruby program 

    -   Please check myFirst.rb, summarize.rb, and argv.rb in the test folder

-  Chapter 6 Classes, Objects and Modules

    -   Return Statement

        It's not necessary to use return to return values from methods in Ruby. The last expression within the method is used as the return bu default.
        If it feels right for the situation or seems clearer to you, however, you can certainly use return with impunity!

    -   Local, Global, Object and Class Variables

        -   Local variables

            def basic_method
                x = 50
                puts x
            end

        -   Global variables

            def basic_method
            puts $x
            end

        -   Object Variables

            class Square
                def initialize(side_length)
                    @side_length = side_length
                end
                def area
                    @side_length * @side_length
                end
            end

            a = Square.new(10)
            b = Square.new(5)
            puts a.area
            puts b.area

            100
            25

        -   Class Variables

            class Square
                def initialize
                    if defined?(@@number_of_squares)
                        @@number_of_squares += 1
                    else
                        @@number_of_squares = 1
                    end
                end
                
                def self.count
                    @@number_of_squares
                end
            end

            a = Square.new
            b = Square.new
            puts Square.count

            2

        -   Object methods vs Class methods

            "self." is used to denote a class method. Please see test/Square.rb for more detail.

        -   Inheritance

            "<" is used to inherit from a parent class. Pls refer to test/parent.rb for more detail.

        -   Reflection and Discovering an Object's Methods

            Reflection is the process by which a computer program can inspect, analyze, and modify itself while
            it's running and being used. Ruby takes reflection to an extreme, and allows you to change the functionality 
            of great swathes of the language itself while running your own code.

            -   methods() method
        
                a = "This is a test"
                puts a.methods.join(' ')

                The methods method on any object (unless it has been overridden, of course!) returns an array of methods made 
                available by that object.

            -   instance_variables

                It returns the names of any object
                variables associated with an instance (as opposed to class variables):

                class Person
                  attr_accessor :name, :age
                end

                p = Person.new
                p.name = "Fred"
                p.age = 20
                puts p.instance_variables

                ["@age", "@name"]

                note: Ruby 1.9’s implementation of instance_variables returns symbols that refer to the object
                variables rather than strings.

            -   Encapsulation

                Encapsulation is the ability for an object to have certain methods and attributes available for
                use publicly (from any section of code), but for others to be visible only within the class itself
                or by other objects of the same class.

                class Person
                def anyone_can_access_this
                   ...
                end
                
                    private
                    def this_is_private
                       ...
                    end
                    
                    public
                    def another_public_method
                       ...
                    end
                end

                You can also use "private" as a command by passing in symbols representing the methods you want to keep private, like so:

                class Person
                    def anyone_can_access_this; ...; end
                    def this_is_private; ...; end
                    def this_is_also_private; ...; end
                    def another_public_method; ...; end
                    private :this_is_private, :this_is_also_private
                end

                The third form of encapsulation (other than public and private) called protected that makes a method private, but within
                the scope of a class rather than within a single object(??It seems this is different from the protected concept in Java/C++).
                For example, you were unable to directly call a private method outside the scope of that object and its methods. However
                , you can call a protected method from the scope of the methods of any object that's a member of the same class.

                Note:

                Note  Ruby supports ending lines of code with semicolons ( ; ) and allows you to put multiple lines of code
                onto a single line (for example, x = 10; x += 1; puts x ). In this case, it’s been done to save on lines of
                code in the example, although it’s not considered good style in production-quality Ruby code.

                For more detail, please check the person.rb in /test

            -   Polymorphism

                Polymorphism is the concept of writing code that can work with objects of multiple types and
                classes at once. Please see polymorphism.rb for more detail.

            -   Nested Classes

                Nested classes are useful when you want to seperate classes into groups of classes rather than keep them all distinct.

                class Drawing
                    def Drawing.give_me_a_circle
                        Circle.new
                    end

                    class Line
                    end
                    class Circle
                        def what_am_i
                            "This is a circle"
                        end
                    end
                end

                a.Drawing.give_me_a_circle
                puts a.what_am_i
                a = Drawing::Circle.new
                puts a.what_am_i
                #a = Circle.new
                #puts a.what_am_i

                You can create a circle object with either a.Drawing.give_me_a_circle or Drawing::Circle.new.
                But you cannot directly create a circle instance with Circle.new directly.

            -   Modules, Namespaces, and Mix-Ins
            
                Modules provide a structure to collect Ruby classes, methods, and constants into a single,
                separately named and defined unit.

                -   Namespaces
    
                    Modules help to solve name conflicts by providing namespaces that can contain any number of classes, methods,
                    and constants, and allow you to address them directly. Please see the modules.rb as an example.

                -   Max-Ins

                    Ruby doesn't support multiple inheritance. However, in some cases, it can be useful to share functionality 
                    between disparate classes. In this sense, modules act like a sort of “super” class and can be included into other classes,
                    extending that class with the methods the module offers. Please see mixIns.rb for more detail.

                Two keywords:   1) module;  2) include

                module is used to define a module to include classes, methdos and constants.
                include takes a module and includes its contents into the current scope.

                Ruby comes with several modules by standard that you can use. E.g. the Kernel module contains all the "standard" commands (such as load, 
                require, exit, puts, eval...) without getting involved with objects or classes. Two such modules are Enumerable and Comparable.

- Chapter 7 Projects and Libraries

    -   Basic File Inclusion

        You might want to write a number of methods to add to String that you'd like to use in multiple programs. Rather than copy and paste the code each time
        you can copy it out to a separate file and use the require command to load the external file into the current program. For example, put this code in 
        a file called string_extensions.rb:

        class String
          def vowels
            self.scan(/[aeiou]/i)
          end
        end

        and Put this code in a file called vowel_test.rb:

        require 'string_extensions'
        puts "This is a test".vowels.join('-')

        You can also use "load" to load external source-code files into your program. For example:

        load 'string_extensions.rb'
        puts "This is a test".vowels.join('-')

        (!!)Note: load requires a full filename, including the .rb suffix, whereas require assume the .rb suffix.
        Also, With load, the code is loaded and reprocessed anew each time you use the load method. require, on the
        other hand, processes external code only once. Good Ruby programmers usually prefer using "require" instead
        of "load"

    -   Inclusions from Other Directories

        Ruby stores the list of directories to search for included files in a special variable called $:
        (or, if you prefer, $LOAD_PATH). You can see what $: contains by default, using irb:
        $:.each { |d| puts d }

        /usr/local/lib/site_ruby/1.9.1
        /usr/local/lib/site_ruby/1.9.1/x86_64-linux
        /usr/local/lib/site_ruby
        /usr/lib/ruby/vendor_ruby/1.9.1

        If you want to add extra directories to this, 

        $:.push '/your/directory/here'
        require 'yourfile'

        Note: $: is an array so you can do "push" operation

    -   Logic and Including Code

        -   Example 1:

            $debug_mode = 0
            require $debug_mode == 0 ? "normal-classes" : "debug-classes"

        -   Example 2:

            %w{file1 file2 file3 file4 file5}.each { |l| require l }

    -   Libraries

        -   RubyGems(!!)

            RubyGems is a packaging system for Ruby programs and libraries. It enables developers to package their Ruby libraries 
            in a form that's easy for users to maintain and install. RubyGems makes it easy to manage different versions of the 
            same libraries on your machine, and  gives you the ability to install them with a single line at the command prompt.

            Each individually packaged Ruby library (or application) is known simply as a gem or RubyGem. Gems have names, version 
            numbers, and descriptions. You can manage your computer’s local installations of gems using the gem command, available 
            from the command line.

            -   Finding Gems

                To find local gems: gem list --local

                To find remote gems: gem list --remote

                Note: The remote gem server is currently hosted by RubyForge, but you can add other source later on(??how).

                Alternatively, you can use the search features offered by the gem program directly, like so:

                gem query --remote --name-matches class

            -   Installing a Simple Gem

                sudo gem install feedtools

                or gem install hpricot --source http://code.whytheluckystiff.net

                note: --source specifies another remote source site rather than the default one such as RubyForge

            -   Using Gems

                As the RubyGems system isn’t an integrated part of Ruby, it’s necessary to tell your programs
                that you want to use and load gems.

                Let's look at one example:

                require 'rubygems'
                require 'RedCloth'
                r = RedCloth.new("this is a *test* of _using RedCloth_")
                puts r.to_html

                => <p>this is a <strong>test</strong> of <em>using RedCloth</em></p>

                In this example, you first load up the RubyGems library, and then load up the RedCloth
                library with require. When RubyGems is loaded on the first line, the RubyGems library over-
                rides the require method and enables it to be used to load gems as if they were normal, local
                libraries(!!).

            -   Updating and Uninstalling Gems

                sudo gem update
                sudo gem uninstall feedtools

-   Chapter 8 Documentation, Error Handling, Debugging, and Testing

    -   Documentation

        Ruby uses a utility called RDoc to make documentation extremely easy to document your code. For example: 

        rdoc person.rb

        This command tells RDoc to process person.rb and produce the HTML documentation. By default, it does this 
        by creating a directory called doc from the current directory and placing its HTML and CSS files in there.

        -   Basic Formatting(...)
        -   Modifier and Options(...)
        -   Command Options(...)

    -   Debugging and Errors

        -   Exceptions and Error Handling

            -   Raising Exceptions
  
                When an exception is raised (exceptions are said to be raised when they occur within the
                execution of a program), Ruby immediately looks back up the tree of routines that called
                the current one (known as the stack) and looks for a routine that can handle that particular
                exception. If it can’t find any error-handling routines, it quits the program with the raw error
                message.

                E.g.

                irb(main):001:0> puts 10 / 0

                =>

                ZeroDivisionError: divided by 0
                from (irb):1:in `/'
                from (irb):1

                You can use the keyword "raise" to generate an exception. E.g.

                class Person
                  def initialize(name)
                    raise ArgumentError, "No name present" if name.empty?
                  end
                end

                fred = Person.new('')

                => ArgumentError: No name present

                Note: Always provide a message and a class with raise , if possible.

                However, you could create your own type of exception if you wanted to. For example:

                class BadDataException < RuntimeError
                end

                class Person
                  def initialize(name)
                    raise BadDataException, "No name present" if name.empty?
                  end
                end

            -   Handling Exceptions(!!)
  
                In most situations, stopping a program because of a single error isn’t necessary.
                The error might only be minor, or there might be an alternative option to try.  

                Therefore, it’s possible to handle exceptions. In Ruby, the rescue clause is used, 
                along with begin and end, to define blocks of code to handle exceptions. For example:

                begin
                  puts 10 / 0
                rescue
                  puts "You caused an error!"
                end

                => You caused an error!

                rescue's syntax makes handling different exceptions in different ways eash:

                begin
                  ... code here ...
                rescue ZeroDivisionError
                  ... code to rescue the zero division exception here ...
                rescue YourOwnException
                  ... code to rescue a different type of exception here ...
                rescue
                  ... code that rescues all other types of exception here ...
                end

            -   Handling Passed Exceptions

                As well as handling different types of exceptions using different code blocks, it’s possible to
                receive exceptions and use them. This is achieved with a little extra syntax on the rescue block:

                begin
                  puts 10 / 0
                rescue => e
                  puts e.class
                end

                => ZeroDivisionError

            -   Catch and Throw (!!)
 
                Sometimes you want to be able to break out of a thread of execution (say, a loop) during normal operation
                in a similar way to an exception, but without actually generating an error. Ruby provides two methods, catch 
                and throw, for this purpose.

                catch(:finish) do
                  1000.times do
                    x = rand(1000)
                    throw :finish if x == 123
                  end

                  puts "Generated 1000 random numbers without generating 123!"
                end

                Within the catch block you generate 1,000 random numbers, and if the random number is
                ever 123, you immediately escape out of the block using throw :finish. However, if you man-
                age to generate 1,000 random numbers without generating the number 123, the loop and the
                block complete, and you see the message.

                Catch and throw don’t have to be directly in the same scope. throw works from methods
                called from within a catch block:

                def generate_random_number_except_123
                  x = rand(1000)
                  throw :finish if x == 123
                end

                catch(:finish) do
                  1000.times { generate_random_number_except_123 }
                  puts "Generated 1000 random numbers without generating 123!"
                end

        -   The Ruby Debugger

            ruby -r debug debugtest.rb

            Note: -r: Causes Ruby to load the library using require.

            -   Most useful commands:
  
                -   list
                -   step 
                -   cont
                -   break
                -   watch
                -   quit
                
        -   Testing 

            -   Test Driven Development
            -   Behaviol Driven Development
            -   Unit Testing

                With more than a few tests, it soon becomes messy, as there's no logical place for the tests to go and you certainly do not want to
                include tests with your actual functional code. Ruby comes with a library, Test::Unit that makes testing easy and organizes test cases
                into a clean structure. Unit testing is the primary component of test-driven development, and means that you’re testing each individual 
                unit of functionality within a program or system. Test::Unit is Ruby’s official library for performing unit tests.

            -   BenchMarking and Profiling

-   Chapter 9 Files and Databases

    -   File I/O (...)
    -   Text File Databases(...)
    -   Storing Objects and Data Structures

        -   PStore

            PStore is a core Ruby library that allows you to use Ruby objects and data structures as you
            normally would, and then store them in a file. Later on, you can reload the objects back into
            memory from the disk file. This technique is known as object persistence, and relies on a tech-
            nique called marshalling, where standard data structures are turned into a form of flat data
            that can be stored to disk or transmitted over a network for later reconstruction.


            (...)

        -   YAML (standing for YAML Ain’t Markup Language)

            It is a special text-based markup language that was designed as a data serialization format that’s readable by humans.

            (...)

    -   Relational Databases and SQL

-   Chapter 13 Web Application Frameworks: Rails, Sinatra, and Ramaze

    -   Ruby On Rails

        It's an open-source, web application framework. A framework is a set of code libraries and data-structures that provide
        generic functionality which can be used, overridden or further specilized.

        -   2 Principles

            -   DRY - "Don't repeat yourself". It means Concise, consistent code that is easy to maintain. Built DRY, encourage DRY.
            -   Convention over configuration - Sensible defaults(??), only specify unconventional aspects. It can speed development
                and less code to maintain. Extra features for free.

        -   MVC Web Architecture

                      1                   2             3 
            Browser   ->    Controller    ->    Model   -> DataBase
               ^                 |         5             4
               |                 |         <-            <-
               |7                v
               |                 6
               |----------------View (HTML, CSS, JavaScript)
            

        
            Controller: Handle Decisions
            Model:      Handle Data
            View:       Handle Presentation

            In Ruby-On-Rails, We call:

            Controller    ->    ActionController
            View          ->    ActionView
            Model         ->    ActiveRecord

            it also groups ActionController and ActionView together as ActionPack

        -   Bundler

            Two files are associated with Bundler: 1) Gemfile; 2) Gemfile.lock

            Gemfile is the file to tell Bundler which gems are needed for this project and what versions.

            Run: bundle install so that the bundler translates Gemfile into Gemfile.locso that the bundler translates Gemfile into Gemfile.lock

            Tip:

            If running the following failed:

            rake db:migrate

            try:

            bundle exec rake db:migrate

        -   Create a Prject
  
            Let's take using a postgresql as our database as an example:

            rails new simple_cms -d postgresql

            There are a couple sub-folders also created for you:

            app:

            app/controllers:

            app/helpers:

            app/models:

            app/

            Now, rails creates a project called simple_cms with postgresql
    
        -   Accessing a Project

            Start web server

            rails s or rails server

            Note: You may run into the trouble: "Rails server does not start -> Could not find a JavaScript runtime"

            That means you don't have JavaScript runtime installed. Therefore, you need to do this:

            sudo add-apt-repository ppa:chris-lea/node.js
            sudo apt-get -y update
            sudo apt-get -y install nodejs
            
                      

                

-   Questions

    1.  =~ operator

    a = %w{ a b c d e f }
    a.select {|v| v =~ /[aeiou]/}   #=> ["a", "e"]

    ?? What does "v =~" mean here?
    
    the =~ operator matches the regular expression against a string, and it returns either the offset of the match from the string if it is found,
    otherwise nil.

    2.  %w

    %w(foo, bar) is a shortcut for ["foo", "bar"]. Meaning it's a notation to write an array of strings seperated by spaces instead of commas and without
    quotes around them.

-   Notes for my project

    1.  Install those gems

        sudo apt-get install ruby-dev
        sudo gem install carrierwave
        sudo gem install carrierwave_backgrounder
        sudo gem install houston 

    2.  Install rails

        sudo apt-get install libpq-dev
        sudo gem install pg

        (go to the site root directory)
        sudo bundle install

        After running all those steps, the bundler creates a file called Gemfile.lock based on the file Gemfile
